//bootstrap Type System

//: Two Introduction Rules
//: I1. ascription proves implication
forall A: B,B. A => B;
//: I2. quantification proves existence of relational type equations
forall A,B. (A,B);
forall A,B,1. (A,B,1);
forall A,B,1,2. (A,B,1,2);
forall A,B,1,2,x. (A,B,1,2,x);

//: Four Downtyping Elimination Rules, proving up to 5-way quantified relations
//: Kinds double as proof objects as well as guarantors of soundness and strong normalization
//: E1. 2D implies 1D and yields a proof object categorized by the remainder
forall A,B. (A,B) => B :: A<B>;
forall A,B. (A,B) => A :: B<A>;
//: E2. 3D implies 2D and yields a proof object categorized by the remainder
forall A,B,1. (A,B,1) => (B,1) :: A<B,1>;
forall A,B,1. (A,B,1) => (A,1) :: B<A,1>;
forall A,B,1. (A,B,1) => (A,B) :: 1<A,B>;
//: E3. 4D implies 3D and yields a proof object categorized by the remainder
forall A,B,1,2. (A,B,1,2) => (B,1,2) :: A<B,1,2>;
forall A,B,1,2. (A,B,1,2) => (A,1,2) :: B<A,1,2>;
forall A,B,1,2. (A,B,1,2) => (A,B,2) :: 1<A,B,2>;
forall A,B,1,2. (A,B,1,2) => (A,B,1) :: 2<A,B,1>;
//: E4. 5D implies 4D and yields a proof object categorized by the remainder
forall A,B,1,2,x. (A,B,1,2,x) => (B,1,2,x) :: A<B,1,2,x>;
forall A,B,1,2,x. (A,B,1,2,x) => (A,1,2,x) :: B<A,1,2,x>;
forall A,B,1,2,x. (A,B,1,2,x) => (A,B,2,x) :: 1<A,B,2,x>;
forall A,B,1,2,x. (A,B,1,2,x) => (A,B,1,x) :: 2<A,B,1,x>;
forall A,B,1,2,x. (A,B,1,2,x) => (A,B,1,2) :: x<A,B,1,2>;

//: Two Lexical Sorting Elimination Rules
//: E1. Tuple types are lexically sorted into kinds
forall A,B. (A,B) :: sort(A,B)
forall A,B,C. (A,B,C) :: sort(A,B,C)
forall A,B,C,D. (A,B,C,D) :: sort(A,B,C,D)
forall A,B,C,D,E. (A,B,C,D,E) :: sort(A,B,C,D,E)
//: E1. Parameter types are lexically sorted into kinds
forall A,B,C. A<B,C> :: A<..sort(B,C)>
forall A,B,C,D. A<B,C,D> :: A<..sort(B,C,D)>
forall A,B,C,D,E. A<B,C,D,E> :: A<..sort(B,C,D,E)>
forall A,B,C,D,E,F. A<B,C,D,E,F> :: A<..sort(B,C,D,E)>

//: Definition of prelude types and kinds
type Real :: Number;
type Integer :: Number;
type Boolean = True | False;

//: SI Units
type Second :: Unit;
type Metre :: Unit;
type Gram :: Unit;
type Ampere :: Unit;
type Kelvin :: Unit;
type Mole :: Unit;
type Candela :: Unit;

//: SI Metric Prefixes, boxing
type Yotta<u:U::Unit>::Unit = 1000000000000000000000000 * u;
type Zetta<u:U::Unit>::Unit = 1000000000000000000000 * u;
type Exa<u:U::Unit>::Unit   = 1000000000000000000 * u;
type Peta<u:U::Unit>::Unit  = 1000000000000000 * u;
type Tera<u:U::Unit>::Unit  = 1000000000000 * u;
type Giga<u:U::Unit>::Unit  = 1000000000 * u;
type Mega<u:U::Unit>::Unit  = 1000000 * u;
type Kilo<u:U::Unit>::Unit  = 1000 * u;
type Hecto<u:U::Unit>::Unit = 100 * u;
type Deca<u:U::Unit>::Unit  = 10 * u;

type Deci<u:U::Unit>::Unit  = u / 10;
type Centi<u:U::Unit>::Unit = u / 100;
type Milli<u:U::Unit>::Unit = u / 1000;
type Micro<u:U::Unit>::Unit = u / 1000000;
type Nano<u:U::Unit>::Unit  = u / 1000000000;
type Pico<u:U::Unit>::Unit  = u / 1000000000000;
type Femto<u:U::Unit>::Unit = u / 1000000000000000;
type Atto<u:U::Unit>::Unit  = u / 1000000000000000000;
type Zepto<u:U::Unit>::Unit = u / 1000000000000000000000;
type Yocto<u:U::Unit>::Unit = u / 1000000000000000000000000;

//: SI Metric Prefixes, unboxing
type Yotta<u:U::Unit>::Unit => U = u / 1000000000000000000000000;
type Zetta<u:U::Unit>::Unit => U = u / 1000000000000000000000;
type Exa<u:U::Unit>::Unit => U   = u / 1000000000000000000;
type Peta<u:U::Unit>::Unit => U  = u / 1000000000000000;
type Tera<u:U::Unit>::Unit => U  = u / 1000000000000;
type Giga<u:U::Unit>::Unit => U  = u / 1000000000;
type Mega<u:U::Unit>::Unit => U  = u / 1000000;
type Kilo<u:U::Unit>::Unit => U  = u / 1000;
type Hecto<u:U::Unit>::Unit => U = u / 100;
type Deca<u:U::Unit>::Unit => U  = u / 10;

type Deci<u:U::Unit>::Unit => U  = 10 * u;
type Centi<u:U::Unit>::Unit => U = 100 * u;
type Milli<u:U::Unit>::Unit => U = 1000 * u;
type Micro<u:U::Unit>::Unit => U = 1000000 * u;
type Nano<u:U::Unit>::Unit => U  = 1000000000 * u;
type Pico<u:U::Unit>::Unit => U  = 1000000000000 * u;
type Femto<u:U::Unit>::Unit => U = 1000000000000000 * u;
type Atto<u:U::Unit>::Unit => U  = 1000000000000000000 * u;
type Zepto<u:U::Unit>::Unit => U = 1000000000000000000000 * u;
type Yocto<u:U::Unit>::Unit => U = 1000000000000000000000000 * u;
