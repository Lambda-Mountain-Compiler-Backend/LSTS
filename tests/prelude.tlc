//bootstrap Type System

//: Two Introduction Rules
//: I1. ascription proves implication
forall A: B,B. A => B;
//: I2. quantification proves existence of relational type equations
forall A,B. (A,B);
forall A,B,1. (A,B,1);
forall A,B,1,2. (A,B,1,2);
forall A,B,1,2,x. (A,B,1,2,x);

//: Four Elimination Rules, proving up to 5-way quantified relations
//: Kinds double as proof objects as well as guarantors of soundness and strong normalization
//: E1. 2D implies 1D and yields a proof object categorized by the remainder
forall A,B. (A,B) => B :: A<B>;
forall A,B. (A,B) => A :: B<A>;
//: E2. 3D implies 2D and yields a proof object categorized by the remainder
forall A,B,1. (A,B,1) => (B,1) :: A<B,1>;
forall A,B,1. (A,B,1) => (A,1) :: B<A,1>;
forall A,B,1. (A,B,1) => (A,B) :: 1<A,B>;
//: E3. 4D implies 3D and yields a proof object categorized by the remainder
forall A,B,1,2. (A,B,1,2) => (B,1,2) :: A<B,1,2>;
forall A,B,1,2. (A,B,1,2) => (A,1,2) :: B<A,1,2>;
forall A,B,1,2. (A,B,1,2) => (A,B,2) :: 1<A,B,2>;
forall A,B,1,2. (A,B,1,2) => (A,B,1) :: 2<A,B,1>;
//: E4. 5D implies 4D and yields a proof object categorized by the remainder
forall A,B,1,2,x. (A,B,1,2,x) => (B,1,2,x) :: A<B,1,2,x>;
forall A,B,1,2,x. (A,B,1,2,x) => (A,1,2,x) :: B<A,1,2,x>;
forall A,B,1,2,x. (A,B,1,2,x) => (A,B,2,x) :: 1<A,B,2,x>;
forall A,B,1,2,x. (A,B,1,2,x) => (A,B,1,x) :: 2<A,B,1,x>;
forall A,B,1,2,x. (A,B,1,2,x) => (A,B,1,2) :: x<A,B,1,2>;

//: Planned Elimination Rules: lexical ordering of intra-tuple types
//: This should be programmable, but how-so is not clear yet
