//bootstrap Type System

//: Two Introduction Rules
//: I1. ascription proves implication
forall A: B,B. A => B;
//: I2. quantification proves existence of relational type equations
forall A,B. (A,B);
forall A,B,1. (A,B,1);
forall A,B,1,2. (A,B,1,2);
forall A,B,1,2,x. (A,B,1,2,x);

//: Four Downtyping Elimination Rules, proving up to 5-way quantified relations
//: Kinds double as proof objects as well as guarantors of soundness and strong normalization
//: E1. 2D implies 1D and yields a proof object categorized by the remainder
forall A,B. (A,B) => B :: A<B>;
forall A,B. (A,B) => A :: B<A>;
//: E2. 3D implies 2D and yields a proof object categorized by the remainder
forall A,B,1. (A,B,1) => (B,1) :: A<B,1>;
forall A,B,1. (A,B,1) => (A,1) :: B<A,1>;
forall A,B,1. (A,B,1) => (A,B) :: 1<A,B>;
//: E3. 4D implies 3D and yields a proof object categorized by the remainder
forall A,B,1,2. (A,B,1,2) => (B,1,2) :: A<B,1,2>;
forall A,B,1,2. (A,B,1,2) => (A,1,2) :: B<A,1,2>;
forall A,B,1,2. (A,B,1,2) => (A,B,2) :: 1<A,B,2>;
forall A,B,1,2. (A,B,1,2) => (A,B,1) :: 2<A,B,1>;
//: E4. 5D implies 4D and yields a proof object categorized by the remainder
forall A,B,1,2,x. (A,B,1,2,x) => (B,1,2,x) :: A<B,1,2,x>;
forall A,B,1,2,x. (A,B,1,2,x) => (A,1,2,x) :: B<A,1,2,x>;
forall A,B,1,2,x. (A,B,1,2,x) => (A,B,2,x) :: 1<A,B,2,x>;
forall A,B,1,2,x. (A,B,1,2,x) => (A,B,1,x) :: 2<A,B,1,x>;
forall A,B,1,2,x. (A,B,1,2,x) => (A,B,1,2) :: x<A,B,1,2>;

//: Two Lexical Sorting Elimination Rules
//: E1. Tuple types are lexically sorted into kinds
forall A,B. (A,B) :: sort(A,B)
forall A,B,C. (A,B,C) :: sort(A,B,C)
forall A,B,C,D. (A,B,C,D) :: sort(A,B,C,D)
forall A,B,C,D,E. (A,B,C,D,E) :: sort(A,B,C,D,E)
//: E1. Parameter types are lexically sorted into kinds
forall A,B,C. A<B,C> :: A<..sort(B,C)>
forall A,B,C,D. A<B,C,D> :: A<..sort(B,C,D)>
forall A,B,C,D,E. A<B,C,D,E> :: A<..sort(B,C,D,E)>
forall A,B,C,D,E,F. A<B,C,D,E,F> :: A<..sort(B,C,D,E)>

//: Definition of prelude types and kinds
type Real :: Number;
type Integer :: Number;
type Imaginary :: Number;
type Boolean = True | False;

//: SI Units
type Second :: Unit;
type Metre :: Unit;
type Gram :: Unit;
type Ampere :: Unit;
type Kelvin :: Unit;
type Mole :: Unit;
type Candela :: Unit;

//: SI Metric Prefixes
type Yotta<U::Unit>::Unit;
type Zetta<U::Unit>::Unit;
type Exa<U::Unit>::Unit;
type Peta<U::Unit>::Unit;
type Tera<U::Unit>::Unit;
type Giga<U::Unit>::Unit;
type Mega<U::Unit>::Unit;
type Kilo<U::Unit>::Unit;
type Hecto<U::Unit>::Unit;
type Deca<U::Unit>::Unit;

//: SI Metric Prefixes, boxing
forall u:U,Yotta<U>. U => Yotta<U> = 1000000000000000000000000 * u;
forall u:U,Zetta<U>. U => Zetta<U> = 1000000000000000000000 * u;
forall u:U,Exa<U>.   U => Exa<U>   = 1000000000000000000 * u;
forall u:U,Peta<U>.  U => Peta<U>  = 1000000000000000 * u;
forall u:U,Tera<U>.  U => Tera<U>  = 1000000000000 * u;
forall u:U,Giga<U>.  U => Giga<U>  = 1000000000 * u;
forall u:U,Mega<U>.  U => Mega<U>  = 1000000 * u;
forall u:U,Kilo<U>.  U => Kilo<U>  = 1000 * u;
forall u:U,Hecto<U>. U => Hecto<U> = 100 * u;
forall u:U,Deca<U>.  U => Deca<U>  = 10 * u;

forall u:U,Deci<U>.  U => Deci<U>  = u / 10;
forall u:U,Centi<U>. U => Centi<U> = u / 100;
forall u:U,Milli<U>. U => Milli<U> = u / 1000;
forall u:U,Micro<U>. U => Micro<U> = u / 1000000;
forall u:U,Nano<U>.  U => Nano<U>  = u / 1000000000;
forall u:U,Pico<U>.  U => Pico<U>  = u / 1000000000000;
forall u:U,Femto<U>. U => Femto<U> = u / 1000000000000000;
forall u:U,Atto<U>.  U => Atto<U>  = u / 1000000000000000000;
forall u:U,Zepto<U>. U => Zepto<U> = u / 1000000000000000000000;
forall u:U,Yocto<U>. U => Yocto<U> = u / 1000000000000000000000000;

//: SI Metric Prefixes, unboxing
forall U,u:Yotta<U>. Yotta<U> => U = u / 1000000000000000000000000;
forall U,u:Zetta<U>. Zetta<U> => U = u / 1000000000000000000000;
forall U,u:Exa<U>.   Exa<U>   => U = u / 1000000000000000000;
forall U,u:Peta<U>.  Peta<U>  => U = u / 1000000000000000;
forall U,u:Tera<U>.  Tera<U>  => U = u / 1000000000000;
forall U,u:Giga<U>.  Giga<U>  => U = u / 1000000000;
forall U,u:Mega<U>.  Mega<U>  => U = u / 1000000;
forall U,u:Kilo<U>.  Kilo<U>  => U = u / 1000;
forall U,u:Hecto<U>. Hecto<U> => U = u / 100;
forall U,u:Deca<U>.  Deca<U>  => U = u / 10;

forall U,u:Deci<U>.  Deci<U>  => U = 10 * u;
forall U,u:Centi<U>. Centi<U> => U = 100 * u;
forall U,u:Milli<U>. Milli<U> => U = 1000 * u;
forall U,u:Micro<U>. Micro<U> => U = 1000000 * u;
forall U,u:Nano<U>.  Nano<U>  => U = 1000000000 * u;
forall U,u:Pico<U>.  Pico<U>  => U = 1000000000000 * u;
forall U,u:Femto<U>. Femto<U> => U = 1000000000000000 * u;
forall U,u:Atto<U>.  Atto<U>  => U = 1000000000000000000 * u;
forall U,u:Zepto<U>. Zepto<U> => U = 1000000000000000000000 * u;
forall U,u:Yocto<U>. Yocto<U> => U = 1000000000000000000000000 * u;
