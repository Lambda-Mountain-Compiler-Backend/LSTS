
//bootstrap Type System

//: Two Introduction Rules
//: I1. ascription proves implication
forall A: B. A => B

//: I2. quantification proves existence of relational type equation
forall A,B. (A,B)

//: Implication Reduction is Strongly Normalizing
//:
//: 1) All types that strongly normalize have kinds
//: 2) All kinds that have types yield values
//: 3) All finite-length strings are finite-length
//: therefore all strongly normalizing type systems yield finite-length proof objects

//: Three Elimination Rules
//: E1. 3D implies 2D
forall A,B,1. (A,B,1) => (A,B) yields { 1 A B }

//: E2. 4D implies 3D
forall A,B,1,2. (A,B,1,2) => (A,B,1) yields { 1 2 A B }

//: E3. 5D implies 4D if (x,0):2D
//: this rule introduces arbitrary computation into type reduction
//: 0 is the "normalizer function" and hopefully does not diverge
//: evaluating 0 1 2 A B must yield x to reach the ground theorem
forall A,B,1,2,x. (A,B,1,2,x) => (A,B,1,2) yields { 0 1 2 A B }

//: goal, prove all statements assuming (x,0):2D

//: x is a proposition that returns true iff given itself as argument
let x y = x is y

//: 0 is the normalizer function, it is a typed-lambda-calculus expression
let 0 1 2 A B = TODO

//: 2D is the ground theorem i.e. the empty judgement
//: (x,0) is the root assumption
(x,0):2D

