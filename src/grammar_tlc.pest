WHITESPACE = _{ " " | "\n" }
COMMENT = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") |
             ("//" ~ (!"\n" ~ ANY)*) }

dot     = { "." }
upper   = { 'A'..'Z' }
lower   = { 'a'..'z' }
lowerl  = { 'a'..'z' | "_" }
alpha   = { 'a'..'z' | 'A'..'Z' }
alphal  = { 'a'..'z' | 'A'..'Z' | "_" }
digit   = { '0'..'9' }
digital = { '0'..'9' | "_" | "." }
alnum   = { 'a'..'z' | 'A'..'Z' | '0'..'9' }
alnumop = { 'a'..'z' | 'A'..'Z' | '0'..'9' | "+" | "-" | "_" }

typvar     = ${ upper+ }
typname    = ${ upper ~ alnum* }
kindname   = ${ upper ~ alnum* }
simplename = ${ alphal ~ (alphal | digit)* }
quotedname = ${ "$\"" ~ (!"\"" ~ ANY)+ ~ "\"" }
ident      = ${ !("as" | "if" | "else " | "let" | "forall" | "type" | "normal" | "where") ~ ((lowerl~alphal*) | quotedname) }
lident     = ${ dot? ~ ident }
esign      = ${ ("e"|"E") ~ ("+" | "-")? }
numerical  = ${ digit ~ digital* ~ (esign ~ digital+)? }
imaginary  = ${ "+" ~ numerical ~ "i" }
constant   = ${ numerical ~ imaginary? }

normal = { "normal" }
ident_typ_kind = { ident? ~ (":"? ~ typ) ~ ("::" ~ kind)? }
typ_inf_kind = { typvar ~ (":" ~ typ)? ~ ("::" ~ kind)? }

compare_chars = { "==" | "!=" | "<=" | "<" | ">=" | ">" }
compare_op = { compare_chars }
logical_chars = { "&&" | "||" }
logical_op = { logical_chars }
divmul_chars = { "/" | "*" | "%" }
divmul_op = { divmul_chars }
addsub_chars = { "+" | "-" }
addsub_op = { addsub_chars }
prefix_op = { addsub_chars }

key_value = { ident ~ "=" ~ term }
constructor = { typname ~ ("{" ~ (key_value ~ ("," ~ key_value)*)? ~ "}")? }

value_term = { ident | constant | constructor }
app_term = { (tuple_term | value_term) ~ (field_term | tuple_term)* }
field_term = { "." ~ ident }
tuple_term = { "(" ~ (term ~ ("," ~ term)*)? ~ ")" }
atom_term  = { app_term }
prefix_term = { prefix_op? ~ atom_term }
divmul_term = { prefix_term ~ (divmul_op ~ prefix_term)* }
addsub_term = { divmul_term ~ (addsub_op ~ divmul_term)* }
compare_term = { addsub_term ~ (compare_op ~ addsub_term)* }
logical_term = { compare_term ~ (logical_op ~ compare_term)* }
infix_term = { logical_term }
algebra_term = { infix_term ~ ("\\" ~ "[" ~ term ~ "|" ~ term ~ "]")* }
ascript_term = { algebra_term ~ (":" ~ typ)? }
as_term = { ascript_term ~ ("as" ~ typ)? }
if_term = { "if" ~ logical_term ~ "then" ~ as_term ~ ("else" ~ term)? }
term = { if_term | as_term }
assume = { term }

ident_typ = { typname ~ ("<" ~ typ ~ ("," ~ typ)* ~ ">")? }
any_typ   = { "?" }
paren_typ = { "(" ~ (typ ~ ("," ~ typ)*)? ~ ")" }
brack_typ = { "[" ~ term? ~ "]" }
dep_typ   = { "[" ~ term ~ "]" }
atom_typ  = { any_typ | paren_typ | ident_typ | dep_typ }
suffix_typ = { atom_typ ~ brack_typ* }
product_typ = { suffix_typ ~ ("*" ~ suffix_typ)* }
ratio_typ = { product_typ ~ ("/" ~ product_typ)? }
arrow_typ = { ratio_typ ~ ("->" ~ ratio_typ)* }
and_typ    = { arrow_typ ~ ("+" ~ arrow_typ)* }
typ       = { and_typ }

kind      = { kindname ~ ("<" ~ kind? ~ ("," ~ kind)* ~ ">")? }

let_stmt = { "let" ~ lident ~ let_stmt_par? ~ (":" ~ typ)? ~ ("::" ~ kind)? ~ ("=" ~ term)? }
let_stmt_par = { "(" ~ ident_typ_kind? ~ ("," ~ ident_typ_kind)* ~ ")" }

key_typ = { ident ~ ":" ~ typ }
constructor_typedef = { typname? ~ ("{" ~ (key_typ ~ ("," ~ key_typ)*)? ~ "}")? }
regex = { "/" ~ (!"/" ~ ANY)+ ~ "/" }
typedef_branch = { regex | constructor_typedef }
typedef = { typedef_branch ~ ("|" ~ typedef_branch)* }

typ_invariant = { ident_typ_kind? ~ ("," ~ ident_typ_kind)* ~ "." ~ term ~ ("|" ~ term)? }
typ_stmt = { "type" ~ normal? ~ typname ~ ("<" ~ typ_inf_kind ~ ("," ~ typ_inf_kind)* ~ ">")? ~ (":" ~ typ)?
                    ~ ("=" ~ typedef)? ~ ("::" ~ kind ~ ("+" ~ kind)*)?
                    ~ ("where" ~ typ_invariant ~ ("and" ~ typ_invariant)*)? }

inference = { typ ~ ("=>" ~ typ)? }
forall_stmt = { "forall" ~ ident_typ_kind? ~ ("," ~ ident_typ_kind)* ~ "." ~ inference ~ ("=" ~ term)? ~ ("::" ~ kind)?}

stmt = { block | typ_stmt | forall_stmt | let_stmt | term } 

block = { "{" ~ stmt? ~ (";" ~ stmt?)* ~ "}" }
file = { SOI ~ stmt? ~ (";" ~ stmt?)* ~ EOI }
