
//Types
type Boolean = True | False;
type Integer        = /^(0|([-]?[1-9][0-9]*))$/;
type Whole          = /^(0|([1-9][0-9]*))$/;
type Binary         = /^(0|([01]+))$/;
type SignedBinary   = /^(0|([-]?[1][01]*))$/;
type Tensor<T> = { };
type Set<E> = { };
type Map<K,V> = { };

type Even:Integer
     where. self%2 | 0;
type Odd:Integer
     where. self%2 | 1;

let not(b:Boolean): Boolean = match b { True => False, False => True, };
let $"&&"(a:Boolean, b:Boolean): Boolean = match (a,b) { (True,True) => True, _ => False, };
let $"||"(a:Boolean, b:Boolean): Boolean = match (a,b) { (False,False) => False, _ => True, };

let $"=="(x:Binary, y:Binary): Boolean = match (x,y) { (p,p) => True, _ => False };
let $"=="(x:SignedBinary, y:SignedBinary): Boolean = match (x,y) { (p,p) => True, _ => False };
let $"=="(x:Whole, y:Whole): Boolean = match (x,y) { (p,p) => True, _ => False };
let $"=="(x:Integer, y:Integer): Boolean = match (x,y) { (p,p) => True, _ => False };

let $"!="(x:Binary, y:Binary): Boolean = not(x == y);
let $"!="(x:SignedBinary, y:SignedBinary): Boolean = not(x == y);
let $"!="(x:Whole, y:Whole): Boolean = not(x == y);
let $"!="(x:Integer, y:Integer): Boolean = not(x == y);

let $"<"(x:Binary, y:Binary): Boolean = match (x,y) {
    (literal '0', literal '1') => True,
    (literal [01], literal [01]) => False,
    (literal [01], literal yp [01]) => True,
    (literal xp [01], literal [01]) => False,
    (literal xp [01]xs, literal yp [01]ys) => match ((literal xp:Binary),(literal yp:Binary)) {
       (p,p) => ((literal xs:Binary) < (literal ys:Binary)),
       _ => ((literal xp:Binary) < (literal yp:Binary)),
    },
};
let $"<"(x:SignedBinary, y:SignedBinary): Boolean = match (x,y) {
    (literal '-' xs, literal '-' ys) => ((literal ys:Binary) < (literal xs:Binary)),
    (literal '-' _, _) => True,
    (_, literal '-' _) => False,
    (literal xs, literal ys) => ((literal xs:Binary) < (literal ys:Binary)),
};
let $"<"(x:Whole, y:Whole): Boolean = x.binary < y.binary;
let $"<"(x:Integer, y:Integer): Boolean = x.binary < y.binary;

let $"<="(x:Binary, y:Binary): Boolean = x==y || x<y;
let $"<="(x:SignedBinary, y:SignedBinary): Boolean = x==y || x<y;
let $"<="(x:Whole, y:Whole): Boolean = x==y || x<y;
let $"<="(x:Integer, y:Integer): Boolean = x==y || x<y;

let $">"(x:Binary, y:Binary): Boolean = not(x <= y);
let $">"(x:SignedBinary, y:SignedBinary): Boolean = not(x <= y);
let $">"(x:Whole, y:Whole): Boolean = not(x <= y);
let $">"(x:Integer, y:Integer): Boolean = not(x <= y);

let $">="(x:Binary, y:Binary): Boolean = not(x < y);
let $">="(x:SignedBinary, y:SignedBinary): Boolean = not(x < y);
let $">="(x:Whole, y:Whole): Boolean = not(x < y);
let $">="(x:Integer, y:Integer): Boolean = not(x < y);

let pos(x: Binary): Binary = x;
let pos(x: SignedBinary): SignedBinary = x;
let pos(x:Whole): Whole = x;
let pos(x: Integer): Integer = x;

let neg(x: Binary): SignedBinary = literal '-' x;
let neg(x: SignedBinary): SignedBinary = match x {
   literal '0' => literal '0',
   literal '-' xs => literal xs,
   literal xs => literal '-' xs,
};
let neg(x:Whole): Integer = literal '-' x;
let neg(x: Integer): Integer = match x {
   literal '0' => literal '0',
   literal '-' xs => literal xs,
   literal xs => literal '-' xs,
};

let $".binary"(x: Integer) :SignedBinary = match x {
   literal '-' xs => neg((literal xs:Whole).binary),
   literal xs => ((literal xs:Whole).binary as SignedBinary),
};
let $".binary"(x: Whole) :Binary = match x {
   literal '0' => literal "0",
   literal '1' => literal "1",
   literal '2' => literal "10",
   literal '3' => literal "11",
   literal '4' => literal "100",
   literal '5' => literal "101",
   literal '6' => literal "110",
   literal '7' => literal "111",
   literal '8' => literal "1000",
   literal '9' => literal "1001",
   literal xp [0-9]xs => ((literal xp:Whole).binary * (1010:Binary) + (literal xs:Whole).binary),
};

let $".decimal"(x: Binary) :Whole;
let $".decimal"(x: SignedBinary) :Integer = match x {
   literal '-' xs => neg((literal xs:Binary).decimal),
   literal xs => ((literal xs:Binary).decimal as Integer),
};

let $"+"(x: Binary, y: Binary) :Binary = match (x,y) {
   (literal '0', _) => literal y,
   (_, literal '0') => literal x,
   (literal '1', literal '1') => literal "10",
   (literal xp '0', literal '0') => literal xp '0',
   (literal xp '0', literal '1') => literal xp '1',
   (literal xp '1', literal '0') => literal xp '1',
   (literal xp '1', literal '1') => match ((literal xp:Binary)+(1:Binary)) { literal xyp => literal xyp '0' },
   (literal xp [01]xs, literal yp [01]ys) => match ((literal xp:Binary) + (literal yp:Binary), (literal xs:Binary) + (literal ys:Binary)) {
      (literal xyp, literal [01]xys) => literal xyp xys,
      (literal xyp, literal '1' [01]xys) => match ((literal xyp:Binary)+(1:Binary)) { literal xypp => literal xypp xys }
   },
};

let $"-"(x: Binary, y: Binary) :Binary;

let $"*"(x: Binary, y: Binary) :Binary = match (x,y) {
   (literal '0', _) => literal "0",
   (_, literal '0') => literal "0",
   (literal '1', _) => literal y,
   (_, literal '1') => literal x,
   (_, literal "10") => literal x "0",
   (_, literal "100") => literal x "00",
   (literal xp [01]xs, literal yp [01]ys) => (
      ((literal xp:Binary)*(literal yp:Binary)) * (100:Binary) +
      ((literal xp:Binary)*(literal ys:Binary)) * (10:Binary) +
      ((literal xs:Binary)*(literal yp:Binary)) * (10:Binary) +
      ((literal xs:Binary)*(literal ys:Binary))
   ),
};

let $"/"(x: Binary, y: Binary) :Binary;

let $"%"(x: Binary, y: Binary) :Binary;

let $"^"(x: Binary, y: Binary) :Binary;


//Sugar
let $"for"(ls: Tensor<A>, A -> B): Tensor<B>;
let $"for"(ls: Tensor<A>, A -> Boolean, A -> B): Tensor<B>;

let set(ls: Tensor<A>): Set<A>;
let map(ls: Tensor<(A,B)>): Map<A,B>;

let range(end: Integer): Tensor<Integer>;
let range(start: Integer, end: Integer): Tensor<Integer>;
let range(start: Integer, end: Integer, step: Integer): Tensor<Integer>;

let tensor(): Tensor<A>;
let tensor(a: A): Tensor<A>;
let tensor(a: A, b: A): Tensor<A>;
let tensor(a: A, b: A, c: A): Tensor<A>;
