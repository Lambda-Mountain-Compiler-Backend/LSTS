
//Types
type Boolean = True | False;
type Integer        = /^(0|([-]?[1-9][0-9]*))$/;
type Whole          = /^(0|([1-9][0-9]*))$/;
type Binary         = /^(0|([01]+))$/;
type SignedBinary   = /^(0|([-]?[1][01]*))$/;
type Tensor<T> = { };
type Set<E> = { };
type Map<K,V> = { };

type Even:Integer
     where. self%2 | 0;
type Odd:Integer
     where. self%2 | 1;

let not(b:Boolean): Boolean = match b { True => False, False => True, };
let $"&&"(a:Boolean, b:Boolean): Boolean = match (a,b) { (True,True) => True, _ => False, };
let $"||"(a:Boolean, b:Boolean): Boolean = match (a,b) { (False,False) => False, _ => True, };

let $"=="(x:Binary, y:Binary): Boolean = match (x,y) { (p,p) => True, _ => False };
let $"=="(x:SignedBinary, y:SignedBinary): Boolean = match (x,y) { (p,p) => True, _ => False };
let $"=="(x:Whole, y:Whole): Boolean = match (x,y) { (p,p) => True, _ => False };
let $"=="(x:Integer, y:Integer): Boolean = match (x,y) { (p,p) => True, _ => False };

let $"!="(x:Binary, y:Binary): Boolean = not(x == y);
let $"!="(x:SignedBinary, y:SignedBinary): Boolean = not(x == y);
let $"!="(x:Whole, y:Whole): Boolean = not(x == y);
let $"!="(x:Integer, y:Integer): Boolean = not(x == y);

let $"<"(x:Binary, y:Binary): Boolean = match (x,y) {
    (literal '0', literal '1') => True,
    (literal [01], literal [01]) => False,
    (literal [01], literal yp [01]) => True,
    (literal xp [01], literal [01]) => False,
    (literal xp [01]xs, literal yp [01]ys) => match ((literal xp:Binary),(literal yp:Binary)) {
       (p,p) => ((literal xs:Binary) < (literal ys:Binary)),
       _ => ((literal xp:Binary) < (literal yp:Binary)),
    },
};
let $"<"(x:SignedBinary, y:SignedBinary): Boolean = match (x,y) {
    (literal '-' xs, literal '-' ys) => ((literal ys:Binary) < (literal xs:Binary)),
    (literal '-' _, _) => True,
    (_, literal '-' _) => False,
    (literal xs, literal ys) => ((literal xs:Binary) < (literal ys:Binary)),
};
let $"<"(x:Whole, y:Whole): Boolean = x.binary < y.binary;
let $"<"(x:Integer, y:Integer): Boolean = x.binary < y.binary;

let $"<="(x:Binary, y:Binary): Boolean = x==y || x<y;
let $"<="(x:SignedBinary, y:SignedBinary): Boolean = x==y || x<y;
let $"<="(x:Whole, y:Whole): Boolean = x==y || x<y;
let $"<="(x:Integer, y:Integer): Boolean = x==y || x<y;

let $">"(x:Binary, y:Binary): Boolean = not(x <= y);
let $">"(x:SignedBinary, y:SignedBinary): Boolean = not(x <= y);
let $">"(x:Whole, y:Whole): Boolean = not(x <= y);
let $">"(x:Integer, y:Integer): Boolean = not(x <= y);

let $">="(x:Binary, y:Binary): Boolean = not(x < y);
let $">="(x:SignedBinary, y:SignedBinary): Boolean = not(x < y);
let $">="(x:Whole, y:Whole): Boolean = not(x < y);
let $">="(x:Integer, y:Integer): Boolean = not(x < y);

let pos(x: Binary): Binary = x;
let pos(x: SignedBinary): SignedBinary = x;
let pos(x:Whole): Whole = x;
let pos(x: Integer): Integer = x;

let neg(x: Binary): SignedBinary = literal '-' x;
let neg(x: SignedBinary): SignedBinary = match x {
   literal '0' => literal '0',
   literal '-' xs => literal xs,
   literal xs => literal '-' xs,
};
let neg(x:Whole): Integer = literal '-' x;
let neg(x: Integer): Integer = match x {
   literal '0' => literal '0',
   literal '-' xs => literal xs,
   literal xs => literal '-' xs,
};

let $".abs"(x: SignedBinary): SignedBinary = match x {
   literal '-' xs => literal xs,
   literal xs => literal xs,
};
let $".abs"(x: Integer): Integer = match x {
   literal '-' xs => literal xs,
   literal xs => literal xs,
};

let $".binary"(x: Integer) :SignedBinary = match x {
   literal '-' xs => neg((literal xs:Whole).binary),
   literal xs => ((literal xs:Whole).binary as SignedBinary),
};
let $".binary"(x: Whole) :Binary = match x {
   literal '0' => literal "0",
   literal '1' => literal "1",
   literal '2' => literal "10",
   literal '3' => literal "11",
   literal '4' => literal "100",
   literal '5' => literal "101",
   literal '6' => literal "110",
   literal '7' => literal "111",
   literal '8' => literal "1000",
   literal '9' => literal "1001",
   literal xp [0-9]xs => ((literal xp:Whole).binary * (1010:Binary) + (literal xs:Whole).binary),
};

let $".decimal"(x: Binary) :Whole = match x {
   literal "0" => 0,
   literal "1" => 1,
   literal "10" => 2,
   literal "11" => 3,
   literal "100" => 4,
   literal "101" => 5,
   literal "110" => 6,
   literal "111" => 7,
   literal "1000" => 8,
   literal "1001" => 9,
   _ => match ((x / (1010:Binary)).decimal, (x % (1010:Binary)).decimal) {
      (literal '0',literal s) => literal s,
      (literal p,literal s) => literal p s,
   },
};
let $".decimal"(x: SignedBinary) :Integer = match x {
   literal '-' xs => neg((literal xs:Binary).decimal),
   literal xs => ((literal xs:Binary).decimal as Integer),
};

let $"+"(x: Binary, y: Binary) :Binary = match (x,y) {
   (literal '0', _) => literal y,
   (_, literal '0') => literal x,
   (literal '1', literal '1') => literal "10",
   (literal xp '0', literal '0') => literal xp '0',
   (literal xp '0', literal '1') => literal xp '1',
   (literal xp '1', literal '0') => literal xp '1',
   (literal xp '1', literal '1') => match ((literal xp:Binary)+(1:Binary)) { literal xyp => literal xyp '0' },
   (literal [01]xp, literal yp [01]ys) => ((literal yp ys:Binary) + (literal xp:Binary)),
   (literal xp [01]xs, literal yp [01]ys) => match ((literal xp:Binary) + (literal yp:Binary), (literal xs:Binary) + (literal ys:Binary)) {
      (literal xyp, literal [01]xys) => literal xyp xys,
      (literal xyp, literal '1' [01]xys) => match ((literal xyp:Binary)+(1:Binary)) { literal xypp => literal xypp xys }
   },
};
let $"+"(x:SignedBinary, y:SignedBinary): SignedBinary = match (x,y) {
   (literal '-' xs, literal '-' ys) => match ((literal xs:Binary) + (literal ys:Binary)) { xys => literal '-' xys },
   (literal '-' xs, literal ys) => fail,
   (literal xs, literal '-' ys) => fail,
   (literal xs, literal ys) => ((literal xs:Binary) + (literal ys:Binary) as SignedBinary),
};
let $"+"(x:Whole, y:Whole): Whole = (x.binary + y.binary).decimal;
let $"+"(x:Integer, y:Integer): Integer = (x.binary + y.binary).decimal;

let decr(x: Binary) :Binary = match x {
   literal '0' => fail,
   literal '1' => literal '0',
   literal xp '1' => literal xp '0',
   literal xp '0' => match decr(literal xp:Binary) { p => literal p '1' },
};
let $"-"(x: Binary, y: Binary) :Binary = if x<y then fail else match (x,y) {
   (literal '0', literal '0') => literal '0',
   (literal '1', literal '0') => literal '1',
   (literal '1', literal '1') => literal '0',
   (literal xp '1', literal '0') => literal xp '1',
   (literal xp '1', literal '1') => literal xp '0',
   (literal xp '0', literal '0') => literal xp '0',
   (literal xp '0', literal '1') => match decr(literal xp:Binary) { p => literal p '1' },
   (literal xp '1', literal yp '0') => match (literal xp:Binary)-(literal yp:Binary) { p => literal p '1' },
   (literal xp '1', literal yp '1') => match (literal xp:Binary)-(literal yp:Binary) { p => literal p '0' },
   (literal xp '0', literal yp '0') => match (literal xp:Binary)-(literal yp:Binary) { p => literal p '0' },
   (literal xp '0', literal yp '1') => match decr((literal xp:Binary)-(literal yp:Binary)) { p => literal p '1' },
};

let $"*"(x: Binary, y: Binary) :Binary = match (x,y) {
   (literal '0', _) => literal "0",
   (_, literal '0') => literal "0",
   (literal '1', _) => literal y,
   (_, literal '1') => literal x,
   (_, literal "10") => literal x "0",
   (_, literal "100") => literal x "00",
   (literal xp [01]xs, literal yp [01]ys) => (
      ((literal xp:Binary)*(literal yp:Binary)) * (100:Binary) +
      ((literal xp:Binary)*(literal ys:Binary)) * (10:Binary) +
      ((literal xs:Binary)*(literal yp:Binary)) * (10:Binary) +
      ((literal xs:Binary)*(literal ys:Binary))
   ),
};

let $".is_odd"(x: Binary): Boolean = match x {
   literal _ '1' => True,
   _ => False,
};
let $".length"(x: Binary): Binary = match x {
   literal [01] => 1,
   literal xp [01] => ((literal xp:Binary)+(1:Binary)),
};
let divmod(x: Binary, y: Binary) :(Binary,Binary) = (
        if y==(0:Binary) then fail
   else if x==(0:Binary) then (0:Binary, 0:Binary)
   else match divmod(x/(10:Binary), y) { (q,r) => (
      match (q*(2:Binary), r*(10:Binary)) { (qq,rr) => (
         match (if x.is_odd then r+(1:Binary) else r) { rrr => (
            if rrr>=y then (rrr-y, qq+(1:Binary)) else (qq, rrr)
         )}
      )}
   )}
);
let $"/"(x: Binary, y: Binary): Binary = divmod(x,y).0;
let $"%"(x: Binary, y: Binary): Binary = divmod(x,y).1;

let $"/"(x: SignedBinary, y: SignedBinary) :SignedBinary;
let $"/"(x: Whole, y: Whole) :Whole;
let $"/"(x: Integer, y: Integer) :Integer;

let $"%"(x: SignedBinary, y: SignedBinary) :SignedBinary;
let $"%"(x: Whole, y: Whole) :Whole;
let $"%"(x: Integer, y: Integer) :Integer;

let $"^"(x: Binary, y: Binary) :Binary;


//Sugar
let $"for"(ls: Tensor<A>, A -> B): Tensor<B>;
let $"for"(ls: Tensor<A>, A -> Boolean, A -> B): Tensor<B>;

let set(ls: Tensor<A>): Set<A>;
let map(ls: Tensor<(A,B)>): Map<A,B>;

let range(end: Integer): Tensor<Integer>;
let range(start: Integer, end: Integer): Tensor<Integer>;
let range(start: Integer, end: Integer, step: Integer): Tensor<Integer>;

let tensor(): Tensor<A>;
let tensor(a: A): Tensor<A>;
let tensor(a: A, b: A): Tensor<A>;
let tensor(a: A, b: A, c: A): Tensor<A>;
