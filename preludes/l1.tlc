//L1 is a term from linguistics that means "native language"

//Types
type U64: Whole           = /^[0-9]+$/;
type I64: Integer         = /^[-]?[0-9]+$/;
type Whole: Integer       = /^[0-9]+$/;
type Integer              = /^[-]?[0-9]+$/;
type U8: U64              = /^[0-9]+$/;
type Boolean: U8          = False | True;
type String               = /^["][^"]*["]$/;

//Implicit Operators
extern $"+"(x: U64, y: U64): U64 = $"+:(U64,U64)->U64";
extern $"-"(x: U64, y: U64): U64 = $"-:(U64,U64)->U64";
extern $"*"(x: U64, y: U64): U64 = $"*:(U64,U64)->U64";
extern $"/"(x: U64, y: U64): U64 = $"/:(U64,U64)->U64";
extern $"%"(x: U64, y: U64): U64 = $"%:(U64,U64)->U64";

extern $"=="(x: U64, y: U64): U8 = $"==:(U64,U64)->U8";
extern $"!="(x: U64, y: U64): U8 = $"!=:(U64,U64)->U8";
extern $"<"(x: U64, y: U64): U8 = $"<:(U64,U64)->U8";
extern $"<="(x: U64, y: U64): U8 = $"<=:(U64,U64)->U8";
extern $">"(x: U64, y: U64): U8 = $">:(U64,U64)->U8";
extern $">="(x: U64, y: U64): U8 = $">=:(U64,U64)->U8";

extern not(b:U8): U8 = $"not:(U8)->U8";
extern $"&&"(a:U8, b:U8): U8 = $"&&:(U8,U8)->U8";
extern $"||"(a:U8, b:U8): U8 = $"||:(U8,U8)->U8";

extern $"as"(x:U64): String = $"as:(U64)->String";

extern range(to: U64): U64[] = $"range:(U64)->U64[]";
extern range(from: U64, to: U64): U64[] = $"range:(U64,U64)->U64[]";
extern range(from: U64, to: U64, step: U64): U64[] = $"range:(U64,U64,U64)->U64[]";

let $"^"(x: U64, n: U64): U64 = if n==0 then 1
                           else if n%2==0 then (x*x)^(n/2)
                           else x*((x*x)^((n - 1)/2));

let .flatmap(iterable: X[], f: (X)->(T[])): T[]; //no body for now, must rewrite term to use

extern .join(xs: String[]): String = $".join(String[])->String";
extern .join2(xs: String[],sep: String): String = $".join(String[],String)->String";

let .join(xs: T[],sep: String): String = (for x:T in xs yield (x as String)).join2(sep);
