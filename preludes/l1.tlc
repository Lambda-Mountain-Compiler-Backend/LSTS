
//Types
type Boolean = True | False;
type Whole: Integer = /^(0|([1-9][0-9]*))$/;
type Integer        = /^(0|([-]?[1-9][0-9]*))$/;
type Tensor<T> = { };
type Set<E> = { };
type Map<K,V> = { };

type Even:Integer
     where. self%2 | 0;
type Odd:Integer
     where. self%2 | 1;

//Operators
let not(b:Boolean)             :Boolean = match b {
   True => False,
   False => True,
};
let $"&&"(a:Boolean, b:Boolean):Boolean = match (a,b) {
   (True,True) => True,
   _ => False,
};
let $"||"(a:Boolean, b:Boolean):Boolean = match (a,b) {
   (False,False) => False,
   _ => True,
};

let pos(x:Integer)             :Integer = x;
let neg(x:Integer)             :Integer = match x {
   literal '0' => literal '0',
   literal '-' xs => literal xs,
   literal xs => literal '-' xs,
};
let add_natural(x:Integer, y:Integer) :Integer = match (x,y) {
   (literal '0', _) => fail,
   (_, literal '0') => fail,
   (literal '-' _, _) => fail,
   (_, literal '-' _) => fail,
   _ => fail,
};
let $"+"(x:Integer, y:Integer) :Integer = (
        if x==0 then y
   else if y==0 then x
   else if x>0 && y>0 then add_natural(x,y)
   else fail
);
let $"-"(x:Integer, y:Integer) :Integer; //sub
let $"*"(x:Integer, y:Integer) :Integer; //mul
let $"/"(x:Integer, y:Integer) :Integer; //div
let $"%"(x:Integer, y:Integer) :Integer = match (x,y) {
   literal '0' => literal '0',
   (literal '0', literal '1') => literal '0',
   (literal '0'a, literal '1') => literal a,
   (literal '0'a b, literal '1') => literal a b,
   (literal '0'a b '0', literal '1') => literal a b,
   (literal '0'a b '0'c, literal '1') => literal a b c,
   (literal '0'a '0'b, literal '1') => literal a b,
   (literal "00", literal '1') => literal "00",
   (literal "00"a, literal '1') => literal a,
   (literal [0-9], literal '1') => literal '0',
   (literal [0-9]a, literal '1') => literal a,
   (literal [0-9]a b, literal '1') => literal a b,
   (literal [0-9]a b [0-9]c, literal '1') => literal a b c,
};
let $"^"(x:Integer, y:Integer) :Integer; //pow

let $"=="(x:Integer, y:Integer):Boolean = match (x,y) {
   (n,n) => True,
   _ => False,
};
let $"!="(x:Integer, y:Integer):Boolean = not(x == y);
let $"<"(x:Integer, y:Integer)  :Boolean = match (x,y) {
   (literal n, literal n) => False,
   (literal '-' xs, literal '-' ys) => not((literal xs: Whole) < (literal ys: Whole)),
   (literal '-' _, _) => True,
   (_, literal '-' _) => False,
   (literal xs, literal ys) => ((literal xs: Whole) < (literal ys: Whole)),
};
let $"<="(x:Integer, y:Integer) :Boolean = x==y || x<y;
let $">"(x:Integer, y:Integer)  :Boolean = not(x <= y);
let $">="(x:Integer, y:Integer) :Boolean = not(x < y);

//Sugar
let $"for"(ls: Tensor<A>, A -> B): Tensor<B>;
let $"for"(ls: Tensor<A>, A -> Boolean, A -> B): Tensor<B>;

let set(ls: Tensor<A>): Set<A>;
let map(ls: Tensor<(A,B)>): Map<A,B>;

let range(end: Integer): Tensor<Integer>;
let range(start: Integer, end: Integer): Tensor<Integer>;
let range(start: Integer, end: Integer, step: Integer): Tensor<Integer>;

let tensor(): Tensor<A>;
let tensor(a: A): Tensor<A>;
let tensor(a: A, b: A): Tensor<A>;
let tensor(a: A, b: A, c: A): Tensor<A>;
