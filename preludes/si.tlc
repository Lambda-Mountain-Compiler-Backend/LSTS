//: Definition of prelude types and kinds
type Boolean = True | False;
type Number;   //Marker trait for numbers. Require declaration to prevent accidental shadowing.
type Integer   : Number; //This is how subtyping relations are defined.
type Real      : Number;
type Imaginary : Number;

//: SI Units
forall :X::Unit. X => Number :: Term; //Units are terms of some numerical type, implying the Number trait marker.
type Second  :: Unit;
type Metre   :: Unit;
type Gram    :: Unit;
type Ampere  :: Unit;
type Kelvin  :: Unit;
type Mole    :: Unit;
type Candela :: Unit;

//: Dimensionless Units
type Angle         :: Unit; //marker trait for Angles
type Degree: Angle :: Unit;
type Radian: Angle :: Unit;
//TODO unit conversion between Angles

type SolidAngle            :: Unit; //marker trait for SolidAngles
type Steradian: SolidAngle :: Unit;

//: SI Derived Units (source: https://www.ece.utoronto.ca/canadian-metric-association/si-derived-units/)
type Hertz: ()/Second :: Unit;
type Newton: Metre*Kilo<Gram>/Second*Second :: Unit;
type Pascal: Kilo<Gram>/Metre*Second*Second :: Unit;
type Joule: Kilo<Gram>*Metre*Metre/Second*Second :: Unit;
type Watt: Kilo<Gram>*Metre*Metre/Second*Second*Second :: Unit;
type Coulomb: Ampere*Second :: Unit; //The constant value of a Coulomb is no longer exactly 1 Ampere Second but the Unit remains unchanged
type Volt: Kilo<Gram>*Metre*Metre/Ampere*Second*Second*Second :: Unit;
type Ohm: Kilo<Gram>*Metre*Metre/Ampere*Ampere*Second*Second*Second :: Unit;
type Siemens: Ampere*Ampere*Second*Second*Second/Kilo<Gram>*Metre*Metre :: Unit;
type Farad: Ampere*Ampere*Second*Second*Second*Second/Kilo<Gram>*Metre*Metre :: Unit;
type Tesla: Kilo<Gram>/Ampere*Second*Second :: Unit;
type Weber: Kilo<Gram>*Metre*Metre/Ampere*Second*Second :: Unit;
type Henry: Kilo<Gram>*Metre*Metre/Ampere*Ampere*Second*Second :: Unit;
type Lumen: Candela*Steradian :: Unit;
type Lux: Candela*Steradian/Metre*Metre :: Unit;
type Becquerel: ()/Second :: Unit;
type Gray: Metre*Metre/Second*Second :: Unit;
type Sievert: Metre*Metre/Second*Second :: Unit;
type SquareMetre: Metre*Metre :: Unit;
type CubicMetre: Metre*Metre*Metre :: Unit;
type Speed: Metre/Second :: Unit;
type Acceleration: Metre/Second*Second :: Unit;
type Jerk: Metre/Second*Second*Second :: Unit;
type Wavenumber: ()/Metre :: Unit;
type Density: Kilo<Gram>/Metre*Metre*Metre :: Unit;
type SurfaceDensity: Kilo<Gram>/Metre*Metre :: Unit;
type SpecificVolume: Metre*Metre*Metre/Kilo<Gram> :: Unit;
type CurrentDensity: Ampere/Metre*Metre :: Unit;
type MagneticFieldStrength: Ampere/Metre :: Unit;
type Concentration: Mole/Metre*Metre*Metre :: Unit;
type MassConcentration: Kilo<Gram>/Metre*Metre*Metre :: Unit;
type Luminance: Candela/Metre*Metre :: Unit;
type RefractiveIndex :: Unit;
type RelativePermeability :: Unit;

//: SI Metric Prefixes
type Yotta<U::Unit> :: Unit;
type Zetta<U::Unit> :: Unit;
type Exa<U::Unit> :: Unit;
type Peta<U::Unit> :: Unit;
type Tera<U::Unit> :: Unit;
type Giga<U::Unit> :: Unit;
type Mega<U::Unit> :: Unit;
type Kilo<U::Unit> :: Unit;
type Hecto<U::Unit> :: Unit;
type Deca<U::Unit> :: Unit;

//: SI Metric Prefixes, boxing
forall u:U,Yotta<U>. U => Yotta<U> = 1000000000000000000000000 * u;
forall u:U,Zetta<U>. U => Zetta<U> = 1000000000000000000000 * u;
forall u:U,Exa<U>.   U => Exa<U>   = 1000000000000000000 * u;
forall u:U,Peta<U>.  U => Peta<U>  = 1000000000000000 * u;
forall u:U,Tera<U>.  U => Tera<U>  = 1000000000000 * u;
forall u:U,Giga<U>.  U => Giga<U>  = 1000000000 * u;
forall u:U,Mega<U>.  U => Mega<U>  = 1000000 * u;
forall u:U,Kilo<U>.  U => Kilo<U>  = 1000 * u;
forall u:U,Hecto<U>. U => Hecto<U> = 100 * u;
forall u:U,Deca<U>.  U => Deca<U>  = 10 * u;

forall u:U,Deci<U>.  U => Deci<U>  = u / 10;
forall u:U,Centi<U>. U => Centi<U> = u / 100;
forall u:U,Milli<U>. U => Milli<U> = u / 1000;
forall u:U,Micro<U>. U => Micro<U> = u / 1000000;
forall u:U,Nano<U>.  U => Nano<U>  = u / 1000000000;
forall u:U,Pico<U>.  U => Pico<U>  = u / 1000000000000;
forall u:U,Femto<U>. U => Femto<U> = u / 1000000000000000;
forall u:U,Atto<U>.  U => Atto<U>  = u / 1000000000000000000;
forall u:U,Zepto<U>. U => Zepto<U> = u / 1000000000000000000000;
forall u:U,Yocto<U>. U => Yocto<U> = u / 1000000000000000000000000;

//: SI Metric Prefixes, unboxing
forall U,u:Yotta<U>. Yotta<U> => U = u / 1000000000000000000000000;
forall U,u:Zetta<U>. Zetta<U> => U = u / 1000000000000000000000;
forall U,u:Exa<U>.   Exa<U>   => U = u / 1000000000000000000;
forall U,u:Peta<U>.  Peta<U>  => U = u / 1000000000000000;
forall U,u:Tera<U>.  Tera<U>  => U = u / 1000000000000;
forall U,u:Giga<U>.  Giga<U>  => U = u / 1000000000;
forall U,u:Mega<U>.  Mega<U>  => U = u / 1000000;
forall U,u:Kilo<U>.  Kilo<U>  => U = u / 1000;
forall U,u:Hecto<U>. Hecto<U> => U = u / 100;
forall U,u:Deca<U>.  Deca<U>  => U = u / 10;

forall U,u:Deci<U>.  Deci<U>  => U = 10 * u;
forall U,u:Centi<U>. Centi<U> => U = 100 * u;
forall U,u:Milli<U>. Milli<U> => U = 1000 * u;
forall U,u:Micro<U>. Micro<U> => U = 1000000 * u;
forall U,u:Nano<U>.  Nano<U>  => U = 1000000000 * u;
forall U,u:Pico<U>.  Pico<U>  => U = 1000000000000 * u;
forall U,u:Femto<U>. Femto<U> => U = 1000000000000000 * u;
forall U,u:Atto<U>.  Atto<U>  => U = 1000000000000000000 * u;
forall U,u:Zepto<U>. Zepto<U> => U = 1000000000000000000000 * u;
forall U,u:Yocto<U>. Yocto<U> => U = 1000000000000000000000000 * u;

//: SI Constants
let c: Metre/Second = 299_792_458;      //speed of light in vacuum
let h: Joule*Second = 6.626_070_15e−34; //Planck constant
let e: Coulomb = 1.602_176_634e−19;     //elementary charge
let k: Joule/Kelvin = 1.380_649e−23;    //Boltzmann constant
let K_cd: Lumen/Watt = 683;             //luminous efficacy of a defined visible radiation
let N_A: ()/Mole = 6.022_140_76e23;     //Avogadro constant
let DeltavCs: Hertz = 9_192_631_770;    //caesium hyperfine frequency
